lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(10, 5))
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(100, 5))
x <- list(a = 1:4, b = norm(10), c = rnorm(20, 1), d = rnorm(100, 5))
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
x <- 1:4
lapply (x, runif)
runif(2)
?runif
lapply (x, runif, min = 1, max = 10)
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
x
lapply(x, function(elt) elt[, 1])
x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)
sapply(x, mean)
mean(x)
x <- matrix(rnorm(200), 20, 10)
apply(x, 2, mean) # Gives mean of all 10 columns
apply(x, 1, sum) # Gives sum of all 20 rows
# Use apply to calculate the 25th and 75th %s of quantiles for rows:
x < matrix(rnorm(200), 20, 10)
x
apply(x, qantile, probs = c(0.25, 0.75))
apply(x, 1, qantile, probs = c(0.25, 0.75))
apply(x, 1, quantile, probs = c(0.25, 0.75))
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean)
rowMeans(a, dims = 2)
# Instead of:
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))
# This is better using mapply:
mapply(rep, 1:4, 4:1)
noise <- function(n, mean, sd) {
rnorm(n, mean, sd)
}
noise(5, 1, 2)
noise(1:5, 1:1, 2)
# Use:
mapply(noise, 1:5, 1:5, 2)
colmean <- function(mat, remNA = TRUE) {
colnum <- ncol(mat) # Find number of columns
matmean <- numeric(colnum) # Create a numeric vector equal to number of columns
for(i in 1:colnum) {
matmean[i] <- mean(mat[, i], na.rm = remNA) # Loop through each column and get mean. If NAs are found, remove them.
}
matmean
}
colmean(airquality)
airquality[good, ][1:6, ]
airquality[1:6, ] # Contains some rows with NA values
good <- complete.cases(airquality)
airquality[good, ][1:6, ]
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
f
tapply(x, f, mean)
# The above example without simplification:
tapply(x, f, mean, simplify = FALSE)
# Example to find group ranges:
tapply(x, f, range)
# Example to find group ranges:
tapply(x, f, range, simplify = TRUE)
# Example to find group ranges:
tapply(x, f, range)
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
split(x, f)
?gl
# It is commont to use lapply and split:
lapply(split(x, f))
# It is commont to use lapply and split:
lapply(split(x, f), mean)
# Splitting a dataframe
library(datasets)
head(airquality)
head(airquality, DESC = $Wind)
head(airquality, DESC = ,Wind)
head(airquality)
head(airquality)
s <- airquality(airquality, airquality$Month)
s <- splitairquality, airquality$Month)
s <- split(airquality$Month)
head(airquality)
s <- split(airquality$Month)
s <- split(airquality, airquality$Month)
s
lapply(s, function(X) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
# Using sapply will return a matrix as the output is combos of 3:
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
# Removing NA values using sapply:
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))
# Splitting on more than one level:
x <- rnorm(10)
f1 <- gl(2, 5)
f2 <- gl(5, 2)
f1
f2
interaction(f1, f2)
?interaction
# Interactions can create empty levels:
str(split(x, list(f1, f2)))
# The drop argument helps remove the empty levels:
str(split(x, list(f1, f2), drop = TRUE))
log(-1)
?invisible
printmessage(0)
printmessage <- function(x) {
if(x > 0)
print("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x)
}
printmessage(0)
print("x is less than or equal to zero")
printmessage(1)
printmessage <- function(x) {
if(x > 0)
print("x is greater than zero")
else
print("x is less than or equal to zero")
x
}
printmessage(5)
printmessage <- function(x) {
if(x > 0)
print("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x)
}
printmessage(5)
printmessage <- function(x) {
if(x > 0)
print("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x) # Returns the value but not shown as output on screen.
}
printmessage(5)
printmessage(NA)
printmessage(1)
printmessage(NA)
printmessage2 <- function(x) {
if(is.na(x))
print("x is a missing value!")
else if (x > 0)
print("x is greater than zero")
else
print("x is less than or equal to zero")
invisible(x)
}
printmessage(NA)
printmessage2(NA)
x <- log(-1)
printmessage2(x)
mean(x)
mean(x)
traceback()
traceback()
lm(y ~ x)
traceback()
debug(lm)
lm(y ~ x)
n
options(error = recover)
read.csv("nosuchfile")
library(swirl)
swirl()
head(flags)
dim(flags)
viewinfo()
class(flags)
cls_list <- lapply(flags, class)
cls_list
class(cls_list)
as.character(cls_list)
cls_list <- sapply(flags, class)
cls_vect <- sapply(flags, class)
class(cls_vect)
sum(flags$orange)
flag_colors <- flags[, 11:17]
head(flag_colors)
lapply(flag_colors, sum)
sapply(flag_colors, sum)
sapply(flag_colors, mean)
flag_shapes <- flags[, 19:23]
lapply(flag_shapes, range)
shape_mat <- sapply(flag_shapes, range)
shape_map
shape_mat
class(shape_mat)
unique(c(3, 4, 5, 5, 5, 6, 6))
unique_vals <- lapply(flags, unique)
unique_vals
sapply (unique_vals, length)
sapply(unique_vals, unique)
sapply(flags, unique)
lapply(unique_vals, function(elem) elem[2])
sapply(flags, unique)
vapply(flags, unique, nueric(1))
ok()
sapply(flags, class)
vapply(flags, class, character(1))
?tapply
flags$landmass
table(flags$landmass)
table(flags$animate)
tapply(flags$animate, flags$landmass, mean)
tapply(flags$population, flags$red, summary)
tapply(flags$population, flags$landmass, summary)
data(iris)
data(iris)
head(iris)
# There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? Please round your answer to the nearest whole number.
# (Only enter the numeric result and nothing else.)
mean(iris$Sepal.Length)
# Q2
# Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?
class(apply(iris, 2, mean))
# Q2
# Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?
class(apply(iris[, 1:4], 2, mean))
apply(iris[, 1:4], 2, mean))
apply(iris[, 1:4], 2, mean)
test <- apply(iris[, 1:4], 2, mean)
class(test)
type(test)
class(test)
test <- apply(iris[, 1:4], 1, mean)
apply(iris[, 1:4], 1, mean)
rowMeans(iris[, 1:4])
# Q2
# Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?
apply(iris[, 1:4], 2, mean)
data(mtcars)
# There will be an object names 'mtcars' in your workspace. You can find some information about the dataset by running
?mtcars
# How can one calculate the average miles per gallon (mpg) by number of cylinders in the car (cyl)? Select all that apply.
# Answer:
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(mtcars, mtcars$cyl, unique)
sapply(mtcars$cyl, unique)
tapply(mtcars$cyl, unique)
lapply(mtcars$cyl, unique)
sapply(mtcars$cyl, unique)
# How can one calculate the average miles per gallon (mpg) by number of cylinders in the car (cyl)? Select all that apply.
# Answer:
tapply(mtcars$mpg, mtcars$cyl, mean)
sapply(split(mtcars$mpg, mtcars$cyl, mean))
with(mtcars, tapply(mpg, cyl, mean))
split(mtcars, mtcars$cyl)
apply(mtcars, 2, mean)
lapply(mtcars, mean)
sapply(split(mtcars$mpg, mtcars$cyl, mean))
sapply(split(mtcars$mpg, mtcars$cyl, mean))
mean(mtcars$mpg, mtcars$cyl)
mean(mtcars$mpg, mtcars$cyl)
sapply(mtcars, cyl, mean)
sapply(mtcars, cyl, mean)
tapply(mtcars$hp, mtcars$cyl, mean)
tapply(mtcars$hp, mtcars$cyl(4), mean)
tapply(mtcars$hp, mtcars$cyl(,4), mean)
split(mtcars, mtcars$cyl)
tt=tapply( mtcars$hp, mtcars$cyl, FUN = mean)
print(tt[4])
tt=tapply( mtcars$hp, mtcars$cyl, FUN = mean, na.rm = FALSE)
print(tt[4])
tapply(mtcars$hp, mtcars$cyl, mean)
# Q4
# Continuing with the 'mtcars' dataset from the previous Question, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars?
S <- tapply(mtcars$hp, mtcars$cyl, mean)
S
# Q4
# Continuing with the 'mtcars' dataset from the previous Question, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars?
s <- tapply(mtcars$hp, mtcars$cyl, mean)
class(s)
s
s(s$4)
s(s$4)
s(,1)
s(1)
s[1]
print(s[3] - s[1])
s[3] - s[1]
# Q5
# If you run
debug(ls)
# what happens when you next call the 'ls' function?
ls(5)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
# There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? Please round your answer to the nearest whole number.
# (Only enter the numeric result and nothing else.)
# Answer:
mean(iris$Sepal.Length)
# There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? Please round your answer to the nearest whole number.
# (Only enter the numeric result and nothing else.)
# Answer:
mean(iris$Sepal.Length, rm.na = TRUE)
q
OK()
## and give it as the returned value which will also be cached.
## If the calculated value is cached, it will not calculate the
## inverse and only return the cached inverse of the matrix.
## Write a short comment describing this function
## The first function, makeCacheMatrix creates a special "matrix",
## which is really a list containing a function to
## set the values of the matrix
## get the values of the matrix
## set the values of the inverse matrix
## get the values of the inverse matrix
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## Write a short comment describing this function
## The following function calculates the inverse of the
## special "matrix" created with the above function.
## However, it first checks to see if the inverse has
## already been calculated. If so, it gets the inverse
## from the cache and skips the computation. Otherwise,
## it calculates the inverse of the matrix and sets the
## value of the inverse in the cache via the setsolve function.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
det(matrix(c(5, 23, 3, 7), nrows = 2, ncol = 2))
det(matrix(c(5, 23, 3, 7), nrow = 2, ncol = 2))
aMatrix <- makeCacheMatrix(matrix(c(5, 23, 3, 7), nrows = 2, ncol = 2))
cacheSolve(aMatrix)
det(matrix(c(5, 23, 3, 7), nrow = 2, ncol = 2))
aMatrix <- makeCacheMatrix(matrix(c(5, 23, 3, 7), nrow = 2, ncol = 2))
cacheSolve(aMatrix)
# str Function
# It compactly displays the internal structure of an R object
# A diagnostic function and an alternative to R 'summary'
# It is especially well suited to compactly display the (abbreviated) contents of (possibly nested) lists.
# Rough one line per basic object
str(str)
srt(lm)
str(lm)
str(ls)
x <- rnorm(100, 2, 4)
summary(x)
str(x)
str(str)
str(lm)
str(ls)
x <- rnorm(100, 2, 4)
summary(x)
str(x)
f
f <- gl(40, 10)
str(f)
sd(x)
?rnorm
mean(x)
?gl
# Output:  Factor w/ 40 levels "1","2","3","4",..: 1 1 1 1 1 1 1 1 1 1 ...
summary(f)
class(f)
# Output:
#  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
# 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
# 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
# 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
library(datasets)
head(airquality)
str(airquality)
m <- matrix(rnorm(100), 10, 10)
str(m)
s <- split(airquality, airquality$Month)
str(s)
s1 <- str(s)
s1 <- str(s)
s1
s1 <- str(s)
s1 <- str(s)
s1 <- s$`5`
s1
hist(rnorm(100))
hist(rnorm(100))
hist(rnorm(100))
hist(rnorm(100))
x <- rnorm(10)
x
x <- rnorm(10, 20, 2)
x
summary(x)
summary(x)
?set.seed
set.seed(1) # Fixes the random number generation
rnorm(5) # Random numbers set generated
rnorm(5) # New random numbers generated
set.seed(1)
rnorm(5) # Earlier list of random numbers generated
# Generating Poisson data
rpois(10, 1)
rpois(10, 2)
class(rpois(10, 1))
type(rpois(10, 1))
# Output: [1] 4 1 2 0 1 1 0 1 4 1
rpois(10, 20)
# Cumulative Distribution with Poisson:
ppois(2, 2)
ppois(4, 2) # Pr(x <= 2) # What is the probability that a Poisson random variable is less than or equal to 4
ppois(6, 2) # Pr(x <= 2) # What is the probability that a Poisson random variable is less than or equal to 6
# Simulation in R
# Simulating a Linear Model
# Generating Random Numbers from a Linear Model
# Example of a linear model to be generated:
# y = β₀ + β₁x + ε
# Where ε ~ N(0.2²). Assume x ~ N(1.0²), β₀ = 0.5 and  β₁ = 2
set.seed(20)
x <- rnorm(100)
e <- rnorm(100, 0, 2)
y <- 0.5 + 2 * x + e
summary(y)
plot(x, y)
# Output:
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# -6.4084 -1.5402  0.6789  0.6893  2.9303  6.5052
y <- plot(x, y)
y
# Output:
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# -6.4084 -1.5402  0.6789  0.6893  2.9303  6.5052
plot(x, y)
x <- rnorm(100)
e <- rnorm(100, 0, 2)
y <- 0.5 + 2 * x + e
# Output:
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# -6.4084 -1.5402  0.6789  0.6893  2.9303  6.5052
plot(x, y)
# An example where x is binary:
set.seed(10)
x <- rbinom(100, 1, 0.5)
e <- rnorm(100, 0, 2)
y <- 0.5 + 2 * x + e
summary(y)
# Output:
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# -3.4936 -0.1409  1.5767  1.4322  2.8397  6.9410
plot(x, y)
# Simulating From Poisson Distribution to calculate count instead of continuous variables where
# Y ~ Poisson(μ)
# log μ = β₀ + β₁x # Here, β₀ is the intercept and β₁ is the slope and x is predictor
# β₀ = 0.5 and β₁ = 0.3 We need to use rpois function for this requirement
set.seed(1)
x <- rnorm(100)
log.mu <- 0.5 + 0.3 * x # Gives log of the linear predictor
y <- rpois(100, exp(log.mu)) # Exponentiation of log required to get the mean for the Poisson variables
summary(y)
# Output:
# Min. 1st Qu.  Median    Mean 3rd Qu.    Max.
# 0.00    1.00    1.00    1.55    2.00    6.00
plot(x, y)
# Random Sampling
# The sample function draws randomly from a specified set of (scalar) objects allowing you to
# sample from arbitrary distributions
set.seed(1)
sample(1:10, 4)
sample(1:10, 4) # Will give different numbers from earlier sample
sample("letters", 5)
sample(letters, 5)
sample(1:10) # Since number of values required is not given, it just gives a random order of all the values
sample(1:10)
sample(1:10, replace = TRUE)
