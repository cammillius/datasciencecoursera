#Loop Functions# 

# lapply: Loop over a list and evaluate a function on each element. 
# sapply: Same as lapply but try to simplify the result. 
# apply: Apply a function over the margins of an array. 
# tapply: Apply a function over the subsets of a vector. 
# mapply: Multivariate version of lapply. 
# split: Splits objects into sub-pieces and is mostly used with lapply. 

# lapply returns a list irrespective of the class of the input. 
# If the input is not a list, it will be coerced into one. 

x <- list(a = 1:5, b = rnorm(10))
lapply(x, mean)

x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean)

x <- 1:4 
lapply (x, runif) 

x <- 1:4 
lapply (x, runif, min = 1, max = 10) 

# apply functions make heavy use of anonymous functions or functions created on the fly. 

x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
x
lapply(x, function(elt) elt[, 1])

# sapply: 
# sapply will try to simplify the results of lapply, if possible. 
# If the result is a list where every element is of length 1, a vector is returned. 
# If the result is a list where every element is a vector of same length (> 1), a matrix is returned. 
# If it cannot figure things out, it returns a list. 

x <- list(a = 1:4, b = rnorm(10), c = rnorm(20, 1), d = rnorm(100, 5))
lapply(x, mean) # Gives back a list. 
sapply(x, mean) # Gives back a vector. 
mean(x) # Will get a warning message. 

# apply: 
# apply is used to evaluate a function (often an anonymous one) over the margins of an array. 
# It is mostly used to apply a function to the rows or columns of a matrix. 
# It can be used in general arrays, e.g. taking the average of an array of matrices. 
# It is not really faster than writing a loop, but it works in one line! 

x <- matrix(rnorm(200), 20, 10) 
apply(x, 2, mean) # Gives mean of all 10 columns. Preserves columns and collapses rows. 
apply(x, 1, sum) # Gives sum of all 20 rows. Preserves rows and collapses columns. 

# Some easy shortcuts for calculating matrix sums and means. These are faster when using large matrices: 

rowSums = apply(x, 1, sum)
rowMeans = apply(x, 1, mean) 
colSums = apply(x, 2, sum) 
colMeans = apply(x, 2, mean) 

# Use apply to calculate the 25th and 75th %s of quantiles for rows: 
x < matrix(rnorm(200), 20, 10)
apply(x, 1, quantile, probs = c(0.25, 0.75))

# Average matrix in an array. 
a <- array(rnorm(2 * 2 * 10), c(2, 2, 10))
apply(a, c(1, 2), mean) 
rowMeans(a, dims = 2) 

# mapply: 
# It is a multivariate apply of sorts which applies a function in parallel over a set of arguments. 

# Instead of: 
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1)) 

# This is better using mapply: 
mapply(rep, 1:4, 4:1) 

# Vectorization of a fuction is easier with mapply. 
# For example, instead of: 
noise <- function(n, mean, sd) {
  rnorm(n, mean, sd)
}
noise(5, 1, 2) 
noise(1:5, 1:1, 2) 

# Use: 
mapply(noise, 1:5, 1:5, 2)

# Which is the same as: 
list(noise(1, 1, 2), noise(2, 2, 2), noise(3, 3, 2), noise(4, 4, 2), noise(5, 5, 2)) 

# tapply 
# It is used to apply a function over subsets of vectors. 

# Example of using tapply to take group means: 
x <- c(rnorm(10), runif(10), rnorm(10, 1)) 
f <- gl(3, 10) 
f
tapply(x, f, mean)

# The above example without simplification: 
tapply(x, f, mean, simplify = FALSE) # Gives a list 

# Example to find group ranges: 
tapply(x, f, range)

# split 
# It takes a vector or other objects and splits it into groups determined by a factor or a list of factors. 

x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
split(x, f)

# It is commont to use lapply and split: 
lapply(split(x, f), mean)

# Splitting a dataframe 
library(datasets)
head(airquality)
s <- split(airquality, airquality$Month) # Splits the data by month. 
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")])) # Gets data for the 3 columns by month. 

# Using sapply will return a matrix as the output is combos of 3: 
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))

# Removing NA values using sapply: (na.rm function removes NAs before the mean is calculated) 
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE)) 

# Splitting on more than one level: 
x <- rnorm(10) 
f1 <- gl(2, 5) 
f2 <- gl(5, 2) 
f1 
f2 
interaction(f1, f2)

# Interactions can create empty levels: 
str(split(x, list(f1, f2))) 

# The drop argument helps remove the empty levels: 
str(split(x, list(f1, f2), drop = TRUE)) 

# Debugging - Diagnosing the problem 
# Message: A generic notification / diagnostic message produced by the message function. Execution of the function continues. 
# Warning: An indication that something is wrong but not necessarily fatal. Execution of the message continues. Generated by the warning function. 
log(-1)

# Error: An indication that a fatal problem has occured. Execution stops. Produced by the stop function. 
# Condition: A generic concept for indicating that something unexpected can occur. Progammers can create their own conditions. 

printmessage <- function(x) {
  if(x > 0) 
    print("x is greater than zero") 
  else 
    print("x is less than or equal to zero") 
  invisible(x) # Returns the value but not shown as output on screen. 
}
printmessage(1)
printmessage(NA)# Throws error as it does not understand NA. 

printmessage2 <- function(x) {
  if(is.na(x)) 
    print("x is a missing value!") 
  else if (x > 0) 
    print("x is greater than zero") 
  else 
    print("x is less than or equal to zero") 
  invisible(x)
}
printmessage2(NA)

x <- log(-1) 
printmessage2(x)

# How do you know that something is wrong with your function? 
# What was your input? How did you call the function? 
# What were you expecting? Output, messages, other results? 
# What did you get? 
# How does what you get differ from what you were expecting? 
# Were your expectations correct in the first place? 
# Can you reproduce the problem (exactly)? 

# Some basic functions which help with debugging problems: 
# traceback: prints out the function call stack after an error occurs. Does nothing if there's no error. 
# debug: flags a function for "debug" mode which allows you to step through execution of a function one line at a time. 
# browser: suspends the execution of a function wherever it is called and puts the function in debug mode. 
# trace: allows you to insert the debugging code into a function specific places. 
# recover: allows you to modify the error behavior so that you can browse the function call stack. 

# These are interactive tools specifically designed to allow you to pick through a function. 
# There's also the more blunt technique of inserting print/cat statementin the function. 

mean(x)
traceback()

lm(y ~ x) 
traceback() 

debug(lm)
lm(y ~ x)

options(error = recover) # Does it for the entire R session that is open at this time. 
read.csv("nosuchfile")

# When analyzing a problem, make sure you can reproduce the problem, clearly state expectations and how output differs from expectation. 
# traceback, debug, browser, trace & recover are debugging codes to find problematic areas of code. 

